---
title: "Start Solving"
slug: "solver/start-solving"
description: "All Catalyst orders can be solved permissionlessly. This page introduces you to how to start solving for Catalyst."
sidebar:
  order: 1
---

Catalyst is an entirely permissionless system. Since the system is componentized and components have no inherent trust elements with other components, they can be mixed and matched as desired by users. As a result, it is important that you validate orders in their entirety once received.

The general Catalyst flow is as follows:

import { Steps } from '@astrojs/starlight/components';

<Steps>

1. The sponsor signs a Catalyst-compatible lock and sends it to the Catalyst order server.

2. The Catalyst order server preliminarily validates the order and obtains the allocator co-signature for the order. It is then broadcasted to solvers.

3. A solver submits the order's output to the output settlement contract, starting the verification layer.

    :::note[[Output Settlement](/architecture/output)]
    The output settlement is denoted as the `remoteFiller` in the order struct.
    :::

4. The proof is delivered to the input chain through the validation layer.

    :::note[[Validation Layer](/architecture/validation)]
    The validation layer is denoted as the `localOracle` and `remoteOracle` in the order struct.
    :::

5. The solver submits the order to the input settlement contract, verifying the delivery and unlocking the associated input tokens.

</Steps>

### Orders
The Catalyst system does not define a strict order type, and as a result, there will be differences in how orders are expressed in various systems. Currently, only one order description is supported across all VMs:

```solidity
struct CatalystCompactOrder {
    address user;
    uint256 nonce;
    uint256 originChainId;
    uint32 fillDeadline;
    address localOracle;
    uint256[2][] inputs;
    OutputDescription[] outputs;
}
```

Where `uint256[2][] inputs === [uint256 tokenId, uint256 amount][]` and `OutputDescription`:

```solidity
struct OutputDescription {
    bytes32 remoteOracle;
    bytes32 remoteFiller;
    uint256 chainId;
    bytes32 token;
    uint256 amount;
    bytes32 recipient;
    bytes remoteCall;
    bytes fulfillmentContext;
}
```

The `CatalystCompactOrder` will be used to interface all functions on the input chain. Additionally, once hydrated with a signature, it allows one to verify the validity of an order.

The `CatalystCompactOrder` struct will be signed and stored as a witness in the appropriate lock/claim structure. For TheCompact, this is:

```solidity
struct BatchCompact {
    address arbiter; // Associated settlement contract
    address sponsor; // CatalystCompactOrder.user
    uint256 nonce; // CatalystCompactOrder.nonce
    uint256 expires; // CatalystCompactOrder.fillDeadline
    uint256[2][] idsAndAmounts; // CatalystCompactOrder.inputs
    CatalystWitness witness;
}

struct CatalystWitness {
    uint32 fillDeadline; // CatalystCompactOrder.fillDeadline
    address localOracle; // CatalystCompactOrder.localOracle
    OutputDescription[] outputs; // CatalystCompactOrder.outputs
}
```

To validate an order, ensure that the sponsor and allocator signatures are valid for this EIP-712 signed structure.


## Order Validation

Catalyst allows highly customizable orders. As a result, you may want to add further validation to ensure that you support the order being relayed to you. As a result, it is important to properly validate orders. 

Below the term whitelisted will be used to describe trusted and validated by **you** or **solvers**. When it is written that a token _has_ to be whitelisted, it means **you** trust the token. If a validation layer is whitelisted, it means **you** trust the validation layer, etc.
Whitelisted does not mean permissioned by a central entity.

The following is an attempt at an exhausive list of validations that solvers have to implement. Note! While this list seems exhaustive, you likely do some of these already.

1. `fillDeadline` Ensure that you have sufficient time to fill the order:
    - Time to fill on destination chain, including potential source chain finality.
2. `expiry` Ensure that you have sufficient time to fill, relay, and claim the order:
    - Time to fill on destination chain, including potential source chain finality.
    - Time to send message validation proof to input chain.
    - Time to claim order after validation has been delivered.  
3. Validation layer. Ensure that you support submitting proofs (and if not automatic, also relaying) to the validation layer. Additionally, the `localOracle` and `remoteOracle`s needs to be of the same validation layer.
4. Ensure that you have whitelisted every single `input` token. If one input token is malicious the order may be unclaimable. Additionally, for blacklistable tokens like USDC, ensure that neither you nor the sender is on a blacklist.
5. Ensure that the potential reset period for a resource lock extends beyond the fillDeadline AND there is no active withdrawal.
6. Ensure that the allocatorID is whitelisted. The allocator can block claims from processing (by withdrawing signatures or reusing nonces.)
    - The allocatorID is part of the lock tag for the inputs. (first 12 bytes).
    - Optionally, ensure that the user has sufficient tokens. This should have been validated by the allocator though.
7. For each output:
    1. `output.chainId` is whitelisted.
    2. `remoteOracle` and `localOracle` has been correct configured regarding `originChainId` and `output.chainId`. The config is immutable so this can be done once for each pair.
    3. `output.remoteFiller` is whitelisted.
    4. `output.fulfillmentContext` is decodable and the order type is supported and compatible with `output.remoteFiller`.
    5. `output.token` is whitelisted. Additionally, for blacklistable tokens like USDC, ensure that neither you nor the recipient is on a blacklist.
    6. You have sufficient tokens for `output.amount`.
    7. If the output has `calldata`, that you can execute it and other outputs atomically. For output on different chains, you may have to whitelist recipients if there is `calldata`.
        - On OP-chains, [CrossL2Inbox](https://specs.optimism.io/interop/predeploys.html#validatemessage) needs to be blacklisted.

8. If the order has multiple outputs, ensure that you can fill all outputs and the first output is set to your solver identifier.
9. Validate that the sponsor signature resolves via an ECDSA recover. Otherwise you may have to submit the registration on-chain.
10. Validate the allocator signature. You may have to do an on-chain call.
11. Validate that the allocator nonce (order nonce) has not been spent previously.


If an order has a 0 input or output of a token you have not whitelisted, the order may not be fillable. Be careful about filling orders containing strange tokens.