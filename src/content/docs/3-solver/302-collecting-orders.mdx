---
title: "Collecting Orders"
slug: "solver/orderflow"
description: "Catalyst has two ways of emitting orders: 1. On-chain through the deposit interface or through the Catalyst order server. For ease of integration and to ensure you receive all orders, it is recommended that you connect to the Catalyst order server for events."
sidebar:
  order: 2
  badge:
    text: Devnet!
    variant: caution
---

:::caution[Devnet!]
Catalyst is currently on devnet! There will be one breaking change to the order struct as we [migrate](https://github.com/catalystsystem/catalyst-intent/pull/92) to [TheCompact v1](https://github.com/Uniswap/the-compact/pull/65) and contracts will have to be redeployed twice before mainnet.
:::

import { Tabs, TabItem } from "@astrojs/starlight/components";

The Catalyst order server is a helpful intermediary that allows users to submit intents (orders) and broadcasts those intents to solvers. It serves as a central hub that:

1. Collects user intents from various sources
2. Broadcasts these intents to connected solvers in real-time
3. Tracks the on-chain status of all transactions necessary for the intent to work end-to-end

While the order server is the recommended integration surface for most solvers due to its convenience and comprehensive order delivery, it's important to note that – _for on-chain orders_ – **it's entirely optional**. Catalyst is designed to be fully decentralized, and solvers can choose to directly monitor on-chain events for a more permissionless approach with potentially lower latency.

## 1. Authentication

While authentication is not necessary to subscribe to the order server's WebSocket events, it is required to use some order server's API services.
All solvers need to be authenticated with the Catalyst order server to be able to push their inventory to the order server. Without it, the order server won't be able to offer your quotes to users.
Authentication is handled via API tokens that provide secure access to the order server's protected API services.

##### Obtaining API Access

To get your API token please reach out to the order server team.

##### Using Your API Token

If you have an API token, it must be included in all requests to the order server for reputation purposes:

- For HTTP requests: Include the token in the request headers as `x-api-key: YOUR_API_TOKEN`

## 2. Quotes broadcasting

To avoid the need for solvers to respond to every individual quote request, the order server allows solvers to regularly push their inventory to the order server in the format of `quote chunks`. This approach significantly reduces the overhead for solvers and improves the efficiency of the quoting process.

Solvers can broadcast their available liquidity and pricing information in the following format:

```json
{
  "fromChain": 1, // Ethereum
  "toChain": 8453, // Base
  "fromAsset": "0xA0b86991c...", // USDC on Ethereum, address(0) for native tokens
  "toAsset": "0x123...", // USDC on Base, address(0) for native tokens
  "price": 0.999, // how much toToken per fromToken
  "fixedFee": 0.5, // e.g., 0.5 USDC flat fee
  "maxAmount": 1000000000, // max the solver will handle
  "minAmount": 10000000, // optional minimum amount
  "expiry": 1713296400 // quote expires at this timestamp
}
```

It is important that solvers update their quotes periodically as market conditions change with correct expiry dates. If your quotes expire, the order server will stop using them to match user requests.

:::note[You can overwrite old quotes by sending new quotes]
Overwriting quotes allows you to send longer lived quotes, updating them as markets evolve. Alternativly, you can send very short lived quotes then preemtivly update your quotes.
:::

By broadcasting quotes in this manner, solvers can:

- Efficiently communicate their available liquidity across multiple chain and token pairs
- Set their own pricing and fee structure
- Define limits on transaction sizes they're willing to process
- Update their quotes as market conditions change
- The order server then uses these broadcast quotes to match incoming user requests without needing to query solvers in real-time for every request, resulting in faster quote responses for users and reduced operational overhead for solvers.

Here's a simple JavaScript example showing how to submit quotes to the Catalyst order server:

```javascript
// Using fetch API (browser or Node.js with node-fetch)
async function submitQuote(apiKey, quoteData) {
  const response = await fetch("order-server-uri/quotes/submit", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": apiKey,
    },
    body: JSON.stringify(quoteData),
  });

  if (!response.ok) {
    throw new Error(
      `Error submitting quote: ${response.status} ${response.statusText}`
    );
  }

  return await response.json();
}

// Example usage
const apiKey = "your-api-key-here";
const quote = {
  fromChain: 1,
  toChain: 8453,
  fromAsset: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC on Ethereum
  toAsset: "0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA", // USDC on Base
  price: 0.999,
  fixedFee: 0.5,
  maxAmount: 1000000000,
  minAmount: 10000000,
  expiry: Math.floor(Date.now() / 1000) + 3600, // 1 hour from now
};

// Submit the quote
submitQuote(apiKey, quote)
  .then((response) => console.log("Quote submitted successfully:", response))
  .catch((error) => console.error("Failed to submit quote:", error));
```

## 3. Order subscription

The order subscription system allows solvers to receive real-time order notifications through a WebSocket connection. This subscription-based approach ensures that solvers can immediately process new orders as they enter the system, without needing to continuously poll for updates.

When subscribing to orders, solvers receive structured data containing all necessary information to evaluate and potentially fulfill each order. The subscription system handles automatic reconnection in case of connection issues and provides a robust way to maintain a persistent connection to the order server.

Below are the key types and implementation details for setting up an order subscription:

```typescript

// misc types
interface CatalystEvent<T> {
  event: CatalystWsEventType;
  data: T;
}

export enum CommonWsEvent {
  // Common heartbeat events
  PING = "ping",
  PONG = "pong",
  TCP_PONG = "tcp-pong",
}

export enum CatalystWsEvent {
  APP_ORDER_STATUS_CHANGED = "app:order-status-change",

  USER_ORDER_VM = "user:vm-order-submit",
  USER_ORDER_NON_VM = "user:non-vm-order-submit",
}

export interface CatalystQuoteRequestData {
  quoteRequestId: string;
  fromChain: string;
  toChain: string;
  fromAsset: string;
  toAsset: string;
  expirationTime: string;
  amount: string;
}

// TODO: this should contain the orderId so solver's don't have to derive it.
export interface CatalystOrder {
  order: CompactOrder;
  quotes: QuoteContext;
  meta: CatalystOrderMeta;
  sponsorSignature: string;
  allocatorSignature: string;
}

export interface QuoteContext {
  toAsset: string;
  toPrice: string;
  discount: string;
  fromAsset: string;
  fromPrice: string;
  intermediary: string;
}

export interface CompactOrder {
  type: "CompactOrder"; // Used to identify this as a compact order
  user: string;
  nonce: number;
  originChainId: number;
  fillDeadline: number;
  localOracle: string;
  inputs: [number, number][];
  outputs: OutputDescription[];
}

export interface OutputDescription {
  remoteOracle: string;
  remoteFiller: string;
  token: string;
  amount: number;
  recipient: string;
  chainId: number;
  remoteCall: string;
  fulfillmentContext: string;
}

export interface CatalystOrderMeta {
  submitTime: number;
  orderIdentifier?: string;
  orderStatus?: string;
  connectedWalletId?: string;
  destinationAddress?: string;
  originId?: string;
  confirmationsCount?: number;
  requiredConfirmationsCount?: number;
  orderInitiatedTxHash?: string;
  orderPurchasedTxHash?: string;
  orderProvenTxHash?: string;
  nonVmTxHash?: string;

  signedAt?: Date;
  initiatedAt?: Date;
  pendingTransferAt?: Date;
  settledTransferAt?: Date;
  purchasedAt?: Date;
  provenAt?: Date;
  failedAt?: Date;
  expiredAt?: Date;
}

import { WebSocket } from "ws";

class WebSocketClient {
  private ws: WebSocket;
  private reconnectInterval = 5000; // Reconnect interval in milliseconds
  private wsUri: string;

  constructor(wsUri: string) {
    this.wsUri = wsUri;
    this.connect();
  }

  private connect(): void {
    // Initialize WebSocket connection
    this.ws = new WebSocket(this.wsUri);

    // Connection opened
    this.ws.on("open", () => {
      console.log("Connected to WebSocket server");
      // You can send an initial message here if needed
      this.ws.send(
        JSON.stringify({ type: "hello", message: "Connected to server" })
      );
    });

    // Listen for messages
    this.ws.on("message", async (data: RawData) => {
      try {
        const parsedData: CatalystEvent<unknown> = JSON.parse(data.toString());

        switch (parsedData.event) {
          case CatalystWsEventType.PING:
            this.handleReceivePing();
            break;

          case CatalystWsEventType.VM_ORDER:
            console.log(`[${CatalystWsEventType.VM_ORDER}]`, parsedData);
            // add your custom filling logic in this function
            await this.handleVmOrder(
              parsedData as CatalystEvent<CatalystOrder>
            );
            break;

          default:
            console.log("Unknown message type:", parsedData);
        }
      } catch (error) {
        console.error("Error parsing JSON:", error);
      }
    });

    // Handle errors
    this.ws.on("error", (error) => {
      console.error("WebSocket error:", error);
    });

    // Handle disconnection
    this.ws.on("close", () => {
      console.log("Disconnected from WebSocket server");
      this.reconnect();
    });
  }

  private reconnect(): void {
    console.log(
      `Attempting to reconnect in ${this.reconnectInterval / 1000} seconds...`
    );
    setTimeout(() => {
      this.connect();
    }, this.reconnectInterval);
  }

  public sendMessage(message: any): void {
    if (this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    } else {
      console.warn("WebSocket is not open. Cannot send message.");
    }
  }

  private sendPong(): void {
    this.sendMessage({ type: "pong" });
  }

  public close(): void {
    this.ws.close();
  }
}

// Usage example
const wsUri = "order-server-uri";

// Create WebSocket client
const client = new WebSocketClient(wsUri);

// Keep the process running
process.on("SIGINT", () => {
  console.log("Closing WebSocket connection...");
  client.close();
  process.exit(0);
});
```

## 4. Order filling

#### Evaluating Orders

After fetching an order, the solver must thoroughly evaluate it to determine its viability and potential execution. To facilitate this evaluation, several contextual pointers are available within the returned order data. Key aspects to consider include:

1. **Quote Validation**: Use the `OrderDto.quote` field to access the price context, which provides the pricing details for the inputs and outputs of the order. If you trust the order server, you can primarily rely on this quote to validate the order’s pricing. However, it’s crucial to verify that the solver supports the specific origin chain (`OrderDto.order.originChainId`) and output chains (`OrderDto.order.outputs[...].chainId`) as well as their respective tokens (`input[...][0]` and `output[].token`). These parameters are guaranteed to be present across all order types.

:::note
Tokens inputs are provided as uint256. This is a standard format for resource locks and cross-chain addresses. For EVM, the first 12 bytes is the lock tag and the address is the last 20 bytes.
:::

Evaluating orders carefully ensures that solvers can accurately determine the feasibility of executing an order, adhere to exclusivity rules, and avoid conflicts, thereby maintaining the integrity and efficiency of the order fulfillment process.

#### On-chain Order Broadcast

Output settlement schemes supporting on-chain orders like [`CompactSettlerWithDeposit.sol`](/architecture/input/#with-deposit) or the [LI.FI facet](https://github.com/reednaa/lifi-contracts/blob/catalyst/src/Facets/CatalystFacet.sol) allow anyone to broadcast and collect orders on-chain through either `Deposited` event:

```solidity
/// @dev LI.FI facet since it does not have access to the orderId.
event Deposited(CatalystCompactOrder order);
/// @dev Catalyst Settler since it does has access to the orderId.
event Deposited(bytes32 indexed orderId, CatalystCompactOrder order);
```

:::caution
When collecting permissionless orders, ensure they are properly validated and co-signed. The order server aids with validation, but on-chain, potential fraudulent messages can be emitted.
:::
